const input = require('fs')
  .readFileSync('/dev/stdin')
  .toString()
  .trim()
  .split('\n').map((v) => v.split(' ').map(Number))
const [N, M] = input[0]
const ladders = input.slice(1, 1+N)
const snakes = input.slice(1+N)
const MAX_SIZE = 100
// console.log(ladders, snakes)
const bfs = (start) => {
    const visited = Array.from({ length: MAX_SIZE+1 }, () => false)
    const queue = [[start, 0]] // start, cnt
    let head = 0
    visited[start] = true
    while (queue.length > head) {
        const [v, cnt] = queue[head++]
        // console.log(v, cnt, queue)
        if (v === MAX_SIZE) {
            return cnt
        }
        for (let i = 6; i >= 1; i--) {
            const nextPos = v+i
            if (nextPos > MAX_SIZE) continue
            if (visited[nextPos]) continue
            const targetLadder = ladders.find((l) => l[0] === nextPos)
            if (targetLadder) {
                const jumpPos = targetLadder[1]
                if (visited[jumpPos]) continue
                queue.push([jumpPos, cnt+1])
                visited[jumpPos] = true
                continue
            }
            const targetSnake = snakes.find((s) => s[0] === nextPos)
            if (targetSnake) {
                const jumpPos = targetSnake[1]
                if (visited[jumpPos]) continue
                queue.push([jumpPos, cnt+1])
                visited[jumpPos] = true
                continue
            }
            queue.push([nextPos, cnt+1])
            visited[nextPos] = true
        }
    }
    return null
}

const min = bfs(1)
console.log(min)

/*
15:04

1번 칸에서 시작해서 100번 칸에 도착하기
주사위 최소 몇 번 굴려야 할까?

그리디인가..? 그러기엔 경우의 수가 예측이 어려운데

1->7 (6)
7->12 (5)
12->98

12->97
7 -> 97
-> 일단 목적지가 젤 큰 걸 선택하는 그리디는 아님. 그렇다고 출발지가 작은 것도 따져봐야 할 거 같은데 복잡함. 일단 브루트포스로 시간복잡도 안에 되는지 따져본 이후에 다른 방법을 생각하는 편이 나을 듯

최소로 가는 경우는 사다리를 최대한 이용해야 함 (그리디론1)
사다리를 이용 안 한다고 해서 손해보는 경우는 없음

12 93
94 2
95 3
96 4
97 5
98 6
99 7
-> 아 근데 이럼 아예 100에 도착 못할 테니깐 이런 경우는 없겠네

---
12 81
82 99
-> 이게 더 빠름

12 90
91 93
-> 원큐에 못 감. 목적지 숫자가 무조건 큰 걸 선택하는 게 능사가 아니다.

일단 가장 빨리 갈 수 있는 출발지로 주사위 굴려서 가고,
사다리 타고 갈 수 있는 경우의 수를 다 해보자
현재 위치에서 사다리 타고 갈 수 있는 가장 빠른 출발지 찾기 (그리디론3)
더 이상 사다리 타고 갈 수 있는 출발지가 없으면, 주사위 굴려서 가야 함
주사위를 굴리는데, 어디에 뱀이 있는지 알 수 없으니 가능한 경우의 수를 다 해봐야 할 듯
뱀을 만난다고 해서 스킵할 것이 아니라, 그 위치에서 또다시 사다리 타고 갈 수 있는 가장 빠른 출발지 있는지 보면서 계속 탐색해야 할 듯

사다리 타고 갈 수 있는 가장 빠른 출발지를 어떻게 알지?
무작정 주사위 굴리기엔 비효율적임
현재 위치: 12
사다리 위치: 14, 20, 30
현재 위치 - 사다리 위치: 2, 8, 18
ceil(2/6), ceil(8/6), ceil(18/6)
각각 1번, 2번, 3번 주사위 굴려야 도착 가능
-> 주사위 최소로 굴리는 걸 선택
근데 어차피 주사위 굴리는 수 계산할 필요 없이 사다리 위치가 작은 게 선택되네

근데 왜 가장 빠른 출발지를 찾으려 했지?
그리디가 보장이 되나?
언뜻 생각하기에 브루트포스로 주사위 다 굴려보는 방법이 비효율적인 것 같아서.
시간복잡도는 아직 따져보지 못함. 어떻게 시간복잡도를 계산할 수 있지?
아 맞아 가능한 사다리를 타는 게 이득이라는 판단하에 그리디적 사고를 하게 됐지
그렇다면 그때의 시간복잡도는? 음.. 일단 사다리를 선택해야 하니깐 n만큼. 
가다보면 무한 루프에 빠지는 경우는 없을까?

1->31 (주사위 5번 굴려)
31->62
62->68 (6)

1,2,3,4,..100 worst case 100
1->2,3,4,5,6,7
2->3,4,5,6,7,8 / 3->4,5,6,7,8,9
3->4,5,6,7,8,9 / 4->
6^(약 100)
브루트포스로 할 경우 중복이 너무 많아짐.
dp인가?

1->2 최소 1번 굴려야 함
1->3 최소 1번 굴려야 함
1->4 최소 1번

1->8 사다리 안 타고 주사위만 굴릴 경우 최소 2번
2->4 사다리가 있다고 해도 2번이네
5->7 무조건 사다리를 타면 3번으로 더 안 좋아지네
-> 가능한 많은 사다리를 타는 게 이득이라는 그리디론1 철회

-> 일단 브루트포스로 하면 시간초과고, 그리디론1 철회돼서 고려해볼 방법은 dp

1에서 주사위 굴려서 7까지 도달할 수 있음. 2->4, 5->7 사다리는 무시해도 됨
주사위를 굴려서 도달할 수 있는 목적지 이전에 사다리가 있으면 무시해도 됨. 사다리를 타면 오히려 시간을 뺏는 셈.
-> 주사위를 굴려 도달할 수 있는 목적지보다 크거나 같은 출발지부터의 사다리를 고려해야 함 (그리디론2)
이것도 일종의 그리디긴 하네.
근데 이게 dp로 풀기에는 사다리와 뱀들의 위치가 변수라 점화식을 세울 수 있을지 모르겠음
언뜻 생각하기에 그런 경우의 수를 생각해서 점화식을 세운다는 게 무리가 있어 보임
그래서 일단 그리디를 시도해보려 함.

1에서 갈 수 있는 최대 목적지: 7
7보다 크거나 같은 위치에 있는 사다리를 탐색.

풀리지 않은 의문. 가장 빠른 출발지를 가진 사다리를 선택하는 게 그리디를 보장하는가? (그리디론3)
찾은 예외가 있었던가? 음..모르겠다 예외를 또 찾아봐야하네..
7->40 주사위 안 굴리고 바로 40
9->60 주사위 1번 굴리고 60

현재 위치: 60
66->70 주사위 1번 굴리고 70. 최소 2번 더 굴려야 함.
61->99 주사위 1번 굴리고 99. 1번 더 굴리면 도착
-> 주사위를 굴려 도달할 수 있는 목적지보다 크거나 같은 출발지부터의 사다리를 고려해야 한다는 그리디론2 철회

-> 7번 위치에 있는 사다리보다 9번 위치에 있는 사다리를 탔을 때 더 빨리 도착할 수 있는 경우가 있으므로, 가장 빠른 출발지를 가진 사다리를 선택한다는 그리디론3 철회

지금까지 정리하자면,
브루트포스 -> 6^(약 100) 시간초과 예상 (수많은 중복)
그리디론1: 가능한 많은 사다리를 타는 게 이득이다 -> 기각 (예외 케이스 발견)
그리디론2: 주사위를 굴려 도달할 수 있는 목적지보다 크거나 같은 출발지부터의 사다리를 고려하기 -> 기각 (예외 케이스 발견)
그리디론3: 사다리를 선택할 때, 가장 빠른 출발지를 가진 사다리를 선택하기 -> 기각 (예외 케이스 발견)
dp -> 점화식 생각 못함

음 근데 그리디론1,2,3 다 주어진 예제만 봐도 예외케이스 알 수 있는 거였네
진짜 어쩌지? 이정도면 힌트를 보는 게 나을 수도..
알고리즘 힌트가 그래프래. 응? 어떻게 보면 쉬운 거였을지도..

그래프를 왜 생각 못 했지? 브루트포스 하면 그래프를 떠올릴 법 한데...
생각 못 했던 이유가 있겠지. 경우의 수를 그래프로 따져보기 어렵다고 생각했나.
주사위 한 번 굴리는 걸 그래프 간선 하나라 생각할 수 있겠네. 주사위 굴리는 걸 그래프로 생각하기 어려울 수 있었겠네.
-> 브루트포스의 문제점이 수많은 중복으로 인한 시간초과였는데, 이때 중복을 줄이는 방법을 생각했을 때 visited 배열 등 다른 방법이 있을 수 있는데, 바로 dp로 연결해서 생각했었음. 이때 visited를 고려한 bfs접근 또한 시도해볼 수 있음.
1->2
1->3
...
1->7
이런 식으로. 사다리나 뱀이 아니어도 주사위 굴렸을 때 가능한 경우의 수를 그래프로 만들 수 있겠네
그래프에 visited를 설정해서 중복을 방지할 수 있겠네. 무한 루프 또한 막을 수 있고.
100에 도달한 경우에 대해 최소 depth를 저장하면 되겠네
그래프에 노드 저장할 필요 없이 그냥 배열 bfs 돌려서 for문으로 주사위 가능한 경우의 수 큐에 넣으면서 탐색하면 되겠네

-> killed. 무한루프에 빠짐. 왜?
-> 100을 초과하는 경우 예외 처리 해주어야 함

-> 실패. 답은 3인데 13이 나옴. visited 체크하되 cnt가 더 적게 걸리는 위치에 대해선 큐에 넣어줘야 할 듯. visited를 boolean 대신 cnt로 변경
-> 실패. 답은 3인데 17이 나옴. 왜?..
아 bfs로 하면 걍 100 도달하면 바로 리턴해도 되겠구나. 차피 최소 cnt라. 그럼 visited도 cnt로 할 필요 없겠는걸. 차피 젤 먼저 방문한 애가 cnt 최소라.
-> 실패. 음...
새로운 그리디론: 같은 cnt 안에서도 현재 위치가 큰 거를 먼저 큐에서 빼내야 하나?
근데 앞서 그리디론과 마찬가지로 예외 케이스가 있을 것으로 예상됨. 머릿속에서 시뮬해봐도 그럼.

-> for문을 6부터 돌리고 100 넘어가는 경우 break로 예외처리 했는데 그걸 잘못 했음. break하면 낮은 주사위에 대해 시뮬을 돌릴 수 없음.

-> 시간절약을 위해 ladders랑 snakes도 배열 말고 객체나 map으로 바꿔주고 싶은데. 일단 돌려보고 시간초과나면 해야겠다.

*/