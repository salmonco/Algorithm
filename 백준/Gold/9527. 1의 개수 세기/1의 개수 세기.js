const input = require("fs")
  .readFileSync("/dev/stdin")
  .toString()
  .trim()
  .split("\n").map((v) => v.split(' ').map(BigInt))
const [A, B] = input[0]

const dp = [1n]
for (let i = 1; i <= 55; i++) {
    // n자리 -> dp[n-1] * 2 + 2^n
    dp[i] = dp[i-1] * 2n + (1n<<BigInt(i))
}

const getOneCnt = (n) => {
    const binaryStr = n.toString(2)
    // console.log({n, binaryStr})
    const binaryArr = [...binaryStr].reverse().map(BigInt)
    let sum = 0n
    for (let i = binaryArr.length-1; i >= 0; i--) {
        // console.log({n, i, s: binaryArr[binaryArr.length-1-i], sum})
        if (binaryArr[i] !== 1n) {
            continue
        }
        sum += (dp[i-1] ?? 0n) + n - (1n<<BigInt(i)) + 1n
        n -= (1n<<BigInt(i))
    }
    return sum
}

const ans = getOneCnt(B) - getOneCnt(A-1n)
console.log(ans.toString())

/*
1:15

1초. 10^16

2 ~ 12
이진수로 만들었을 때 1의 개수의 합 구하기

자바스크립트는 숫자를 64비트 부동소수점 형식으로 표현하는데, 64비트로 표현할 수 있는 수의 범위가 2^53 이었나? 어떻게 알았지.. 2^53 -1 이라고 하네.
그러면은 10^16이 그 안에 들어오느냐.. 왜 안들어올 거 같지.. 2^30 -> 1초 -> 10^8
그럼 어떡해. 근데 안 들어오면 애초에 입력으로 어떻게 받아? 그럼 들어온단 소리 아냐?
그럼 들어온다 가정하고..

1을 어떻게 셀 거냐 인데.
일단 이진수 문자열로 바꾸는 건 아닌 거 같음. 왜냐면 그럼 너무 길어지는데 시간초과 예상
비트마스킹이 나을 듯
근데 1의 개수 세는 비트마스킹을 어떻게 하지?

101101 -> 4
111111

음.. 생각이 나지 않는다. 문자열밖엔...
다른사람풀이 보니 누적합 썼음

아 근데 차피 숫자를 이진수 문자열로 바꾸어도 상관 없을 듯. 자바스크립트의 숫자 범위는 숫자에만 해당하니깐. 문자열은 길어져도 상관 없을 듯.
다만 1의 개수 세는데 시간이 오래 걸릴 것이니 최적화가 필요함

일단 10^16을 이진수 문자열로 표현하면 2^60 이니 60비트 정도를 차지해서 길이가 60 정도 될 것 같고.
60만큼 스캔해서 1의 개수 세면 시간초과나나? 그거 자체로는 시간초과 안 나는데,
애초에 10^16 까지의 숫자에 대해 모두 각각 1의 개수 세는 게 말이 안 됨. 10^16만큼 스캔해야 하기 때문. 무조건 시간초과임.

그러면... 이제 누적합이 떠오를 수 있겠네.
근데 누적합어케했더라 기억이 잘 안 난다.
누적합은 중복제거하는 dp인데.
점화식을 어케 세운 거지?

아 쉬운 거군. 걍 초기에 1씩 인덱스 증가해서 스캔해가면서 값 sum구해서 누적합 배열 만들고, y범위 - x범위 사이의 sum값 구하면 됨.
근데.. 우리는 이진수의 1의 개수를 구해야 해. 그걸 어케 연관지어서 생각할 수 있지?

다른사람풀이 보니... 오..
비트의 자리수 단위로 생각했음.
1자리 -> 1 -> dp[0] = 1
2자리 -> 10, 11 -> dp[1] = dp[0] + 1 + 2 = 4
3자리 -> 100, 101, 110, 111 -> dp[2] = dp[1] + 4(최상위 비트 미만에 있는 1의 개수) + 4 (최상위 비트에 있는 1의 개수) = 12
4자리 -> 1000, 1001, 1010, 1100, 1011, 1101, 1110, 1111 -> dp[3] = dp[2] + 12 + 8 = 32
n자리 -> dp[n-1] * 2 + 2^n

1부터 y까지 1의 개수 구한 누적합 배열 만들고, -> 1부터 y까지 돌면서 어떤 수 i 이하의 모든 1의 개수의 합 구하기
누적합[y] - 누적합[x] 해서 총 1의 개수 구하기

참고한 풀이: https://degurii.tistory.com/158
뭔가 이해가 될 것 같으면서도 안 된다..
위 걸 보고 이걸 보니 이해가 된다: https://velog.io/@pjh612/%EB%B0%B1%EC%A4%80-9527%EB%B2%88-1%EC%9D%98-%EA%B0%9C%EC%88%98-%EC%84%B8%EA%B8%B0
어떤 수 i 이하의 모든 1의 개수의 합 구할 때, 어떤 수 i 를 이진수로 봐서 **비트마다** i 이하의 모든 이진수에 대해 1의 개수 구해서 더하는 거임

11111 -> 2^5 -1 까지 수를 나타낼 수 있음
y까지 누적합 배열 구하려면 y값이 비트로 몇자리인지 구해야 한다.
다른사람풀이 보니 걍 최대 비트수인 55까지 구했음

왜 틀렸지ㅣ... bigint를 써야 하나.
그래도 틀림.
*/