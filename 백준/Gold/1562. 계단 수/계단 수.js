const input = require("fs")
  .readFileSync("/dev/stdin")
  .toString()
  .trim()
  .split("\n").map((v) => v.split(' ').map(Number))
const [N] = input[0]
const MOD = 1_000_000_000
const SIZE = 10
// 경우의 수 누적해서 더해가기
const dp = Array.from({ length: N }, () => Array.from({ length: SIZE }, () => Array.from({ length: 1 << SIZE }, () => 0)))
let cnt = 0

for (let k = 1; k < SIZE; k++) { // 젤 첨에 0 은 올 수 없어서 제외
    dp[0][k][1 << k] = 1 // 초기 경우의 수는 1
}

for (let i = 1; i < N; i++) {
    for (let k = 0; k < SIZE; k++) {
        for (let bit = 0; bit < (1 << SIZE); bit++) {
            if (k < SIZE-1) {
                dp[i][k][bit | (1 << k)] += dp[i-1][k+1][bit]
            }
            if (k > 0) {
                dp[i][k][bit | (1 << k)] += dp[i-1][k-1][bit]
            }
            dp[i][k][bit | (1 << k)] %= MOD
        }
    }
}

for (let k = 0; k < SIZE; k++) {
    cnt += dp[N-1][k][(1 << SIZE) - 1] // 0부터 9까지 모든 숫자 방문한 경우만 카운트
    cnt %= MOD
}
console.log(cnt)

/*
00:28

2초. 10^2

인접한 모든 자리의 차이가 1인 수 => 계단수
길이가 N이면서 0부터 9까지 숫자가 모두 등장하는 계단 수가 총 몇 개 있는지?
0으로 시작하는 수는 계단수가 아니다.

N=10
9876543210

N=11
98765432101 10123456789

N=12
987654321012 210123456789
987654321010
987654321210
987654323210
987654343210
987654543210
987656543210
987676543210
987876543210
989876543210

898765432101 101234567898
789876543210

규칙이 있나?..
브루트포스로 다 돌리면 시간복잡도 얼마나오지?
계단수를 다 돌려놓고 0~9 숫자 다 들어가는지 확인해야 할 거 같은데..
그럼일단 계단수 다 돌리는 비용이 9x2^(N-1) -> 시간초과 예상
뭔가 dp라든가 규칙이 있을 거 같은데..

다른사람풀이 보니 dp, 비트마스킹으로 풂
참고한 풀이: https://velog.io/@js43o/%EB%B0%B1%EC%A4%80-1562%EB%B2%88-%EA%B3%84%EB%8B%A8-%EC%88%98

dp[3][2]에 도착했을 때, dp[2][3] 또는 dp[2][1]에서 왔을 거다.

방문한 숫자들에 대한 정보를 시간초과나는 배열 대신 다른 방식으로 표현할 수 있을까? -> 비트마스킹
0000000000 -> 아무것도 방문하지 않았음
0000000101 -> 숫자 '0'과 '2'를 둘 다 방문했음

현재 숫자 k를 방문했으므로 방문 기록에 k를 추가해야 한다.
'지금까지 방문한 숫자 집합'을 나타내는 비트마스크에 (1 << k)을 OR 연산함으로써 수행할 수 있다.

'지금까지 방문한 숫자 집합'을 DP 배열의 3번째 차원 인덱스로 표현하고,
(dp[i][k][0~1023]) 해당 인덱스에 가능한 경로의 수를 값으로 저장
*/